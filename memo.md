# やったこと
- UCBアルゴリズム
- 前半(maxPlayの20% and 期待値1以上のスロットが見つかるまで)notePlay
- 後半はquickPlay
- 期待値として，notePlay結果6割，quickPlay結果4割を利用
- maxPlayの80%までプレイして最大期待値1未満なら打ち切り

## notePlayの活用

ラベル: A-Gのアルファベット
基本的には，スロットの各ラベルの出現頻度を単純にカウントし，期待値を求める．
前半終了時に，一定以上notePlayが行われたスロットに対して，スロット構成の推測を行う．
また，notePlayが一定未満のスロットに対して，ラベル分布に基づいて仮想ラベルを付与する．

## ローカル評価

MM99は相対評価なので，ローカルでの評価をどうするかはポイントとなる．
今回は以下の評価方法を用いた．

以下で最適値を，最適な動きをしたときのコインの期待値と定める．
各テストケースのmaxはほぼすべて最適値に近くなると予想．
最適値は各スロットの期待値がわかっていれば出せて，
- 期待値最大のスロットをquickPlayで回し続ける
- 何もしない
のmaxをとればよい．(別の方法で最適値を上回るケースもあるが無視)
このmaxでスコアを割った値をローカル評価値とした．

### provisionalについて

ローカル評価が正しいなら，provisionalでは自分の苦手ケース(何もしないが最適)が多い気がする．
そうであればsystem test後は一波乱ありそう．

# 日記

## 3/17
多腕バンディット問題の例によくある状況なので，バンディット問題で検索．
とりあえずパッと理解できそうな，Epsilon-GreedyとUCBアルゴリズムを実装してみる．
notePlayはよくわからないので，とりあえずquickPlayを実装．
動作させてみたところ，UCBの方がよさそう．

## 3/18
notePlayの利用法を考える．
スロット結果が得られるので，スロットの構成推測に使えそう．
期待値計算にはラベルの並びは無視してよさそうなので，まずはラベルの頻度のみ利用する．

notePlayはquickPlayと比較して
- コスト大
- 精度大
であり，いつ行っても得られるものはほぼ一緒なので，最初にnotePlay，後でquickPlayを使うのがよさそう．

maxPlayの20%をnotePlayに使うことにして
- ひとまずすべてのスロットに一様にnotePlayを行う
- その期待値をもとに，UCBを用いてquickPlayを回す

動作調整する場合に，ローカル評価をどうするかという問題に当たる．
とりあえずとして各ケースについて，
- 最終コインを初期コインで割ったもの
- 全体の平均を引き，標準偏差で割ったもの
- 全体の最大値で割ったもの(システス同様)
の3種類から総合的に判断することに．

まあまあいい感じに動作するようになったしいけるやろ精神で提出．
このとき800k～820k乗る気でいたが，790kで撃沈．
まあそんなに甘くない．